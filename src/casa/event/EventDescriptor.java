/**
 * <p>Title: CASA Agent Infrastructure</p>
 * <p>Description: </p>
 * <p>Copyright: Copyright 2003-2014, Knowledge Science Group, University of Calgary. 
 * Permission to use, copy, modify, distribute and sell this software and its 
 * documentation for any purpose is hereby granted without fee, provided that the 
 * above copyright notice appear in all copies and that both that copyright notice 
 * and this permission notice appear in supporting documentation.  The  Knowledge 
 * Science Group makes no representations about the suitability of  this software 
 * for any purpose.  It is provided "as is" without express or implied warranty.</p>
 * <p>Company: Knowledge Science Group, University of Calgary</p>
 * @author <a href="http://pages.cpsc.ucalgary.ca/~kremer/">Rob Kremer</a>
 * @version 0.9
 */
package casa.event;

import casa.Act;
import casa.ML;
import casa.Status;
import casa.StatusObject;
import casa.TransientAgent;
import casa.abcl.CasaLispOperator;
import casa.abcl.ParamsMap;
import casa.interfaces.Descriptor;
import casa.interfaces.PolicyAgentInterface;
import casa.ui.AgentUI;
import casa.util.EventPattern;
import casa.util.Pair;
import casa.util.PairComparable;

import java.util.Vector;

import org.armedbear.lisp.Environment;

/**
 * Top-level event descriptor for the lisp interpreter POLICY function.
 * @author  <a href="http://pages.cpsc.ucalgary.ca/~kremer/">Rob Kremer</a>
 */
public class EventDescriptor implements Descriptor<Event> {
	
	/**
	 * An agent used for type checking of {@link #type} against the event type 
	 */
	protected PolicyAgentInterface agent = null;
	
	/**
	 * Describes the type of the event descriptor. 
	 */
	private String type;

	//this will be generated if needed, and cached here once it is generated by getName()
	private String name = null;
	
  private EventPattern pattern = new EventPattern();
	
  /**
   * Simple constructor
   * @param type initialized the {@link #type} attribute.
   */
  public EventDescriptor(PolicyAgentInterface agent, String type, Pair<String,? extends Object>[] pairs) {
  	this.type = type;
  	this.agent = agent;
		if (agent==null) 
			throw new IllegalArgumentException("agent parameter cannot be null");
		if (!agent.isA(type, ML.EVENT)) 
			throw new IllegalArgumentException("eventType parameter '"+type+"' must be a subtype of \""+ML.EVENT+"\"");
		for (Pair<String,? extends Object> pair: pairs) {
			String key = pair.getFirst();
			Object val = pair.getSecond();
			if (ML.ACT.equals(key) && !(val instanceof Act)) throw new IllegalArgumentException("MessageEventDescriptor: ACT is not of type Act");
			pattern.put(key, val);
		}
  }

  
  public EventDescriptor(PolicyAgentInterface agent, String type, Object... pairs) {
  	this(agent, type, makePairs(pairs));
  }
  
  /*protected static Pair<String,Object>[] makePairs(Object... pairs) {
		if (pairs.length%2 !=0) // odd
  	  throw new IllegalArgumentException("An event number of arugments is required.");
    Pair<String,Object>[] ret = new PairComparable[pairs.length/2];	
    for (int i=0, j=1, k=0; i<pairs.length; i=i+2, j=j+2, k++) {
    	if (!(pairs[i] instanceof String))
    	  throw new IllegalArgumentException("Odd numbered arguments must be of type String.");
    	
    	ret[k] = new Pair<String,Object>((String)pairs[i], pairs[j]);			//this line causes an array store exception
    }
    return ret;
  }*/
  
  protected static <T extends Comparable<T>> Pair<String, ? extends T>[] makePairs(Object... pairs) {
		if (pairs.length%2 !=0) // odd
  	  throw new IllegalArgumentException("An even number of arguments is required.");
    Vector<Pair<String, ? extends Object>> ret = new Vector<Pair<String, ? extends Object>>(pairs.length/2);
    for (int i=0, j=1, k=0; i<pairs.length; i=i+2, j=j+2, k++) {
    	if (!(pairs[i] instanceof String))
    	  throw new IllegalArgumentException("Even numbered arguments must be of type (or an instance of) String.");
    	
    	ret.add((Pair<String, ? extends Object>)new PairComparable<String,T>((String)pairs[i], (T)pairs[j]));
    }
    
    Pair<String,? extends T>[] ret2 = new Pair[pairs.length/2];
    for(int i=0; i<ret.size();i++){
    	ret2[i] = (Pair<String,? extends T>)ret.get(i);
    	
    }
    
    return ret2;
  }
  
  /**
	 * @return  returns value of the  {@link #type}  attribute.
	 */
	public String getType() {
		return type;
	}
		
	/**
	 * Returns true if event descriptor matches the <em>event</em> in the context of 
	 * the <em>agent</em>.  The <em>eventInstanceInfo</em> is used to pass any additional
	 * info (such as a message object) for additional context.
	 * @param agent the agent that forms the context of evaluation.
	 * @param event the event to match against.
	 * @param eventInstanceInfo additional context that may be used to determine the match.
	 * @return true if this event descriptor matches the event in the context of the agent and eventInstanceInfo.
	 */
	@Override
	public Status isApplicable(PolicyAgentInterface agent, Event event) {
		if (agent.isA(event.getEventType(), type))
	  	return pattern.matches(agent, event);
		else
			return new Status(-1,"event type "+event.getEventType()+" is not < "+type);
	}

//	public boolean isApplicable(PolicyAgentInterface agent, String eventType) {
//		return agent.isA(eventType, type);
//	}


	public int compareTo(PolicyAgentInterface agent, EventDescriptor o) {
		return type.compareTo(o.type);
	}
	
	/**
	 * Determines if this EventDescriptor should override (replace, takes precidence over) 
	 * the other one such that the other one's associated policy doesn't get executed at
	 * all.  This is not the same as being more general or specific: two EventDescriptors
	 * may be in a sub/super type relationship and both be executable.<br>
	 * Subclasses may override this behaviour.
	 * @param other The EventDescriptor to compare to
	 * @return Returns true iff both have identical performatives, and the <em>act</em>
	 * of this one is more specialized than the <em>act</em> of the other one..
	 */
	public boolean overrides(EventDescriptor other) {
		if (getPerformative()!=null && other.getPerformative()!=null 
				&& getPerformative().equals(other.getPerformative())) {
			// if "this" isa "that", and they aren't equal
			if (agent.isAAct(getAct(),other.getAct()) && !(agent.isAAct(other.getAct(),getAct()))) {
				return true;
			}
		}
		return false;
	}
	
	/**
	 * @return
	 */
	public String getPerformative() {
		Object o = pattern.get(ML.PERFORMATIVE);
		return o==null?null:o.toString();
	}

	/**
	 * @return
	 */
	public Act getAct() {
		Object o = pattern.get(ML.ACT);
		if (o instanceof Act) return (Act)o;
		else return null;
	}

	public EventPattern getPattern(){
		return this.pattern;
	}
	
	public void setPattern(EventPattern p){
		this.pattern = p;
	}

	/**
	 * @return The name of the lisp function that will create an instance of this type
	 */
	protected String getLispFunctionName() {return "EVENT-DESCRIPTOR";}
	
  @Override
	public String toString() {
  	StringBuilder buf = new StringBuilder("(");
  	buf.append(getLispFunctionName()).append(' ')
  	.append(getType()).append(' ')
  	.append(pattern.toString())
  	.append(')');
  	return buf.toString();
  }
	
	
	public String getName() {
		if (name==null) {
		  StringBuilder buf = new StringBuilder(type);
		  Object performative = pattern.get(ML.PERFORMATIVE);
		  if (performative!=null) buf.append('-').append(performative.toString());
		  Object act = pattern.get(ML.ACT);
		  if (act!=null) {
		    String actString = act.toString();
		    if (actString!=null) buf.append('-').append(actString);
		  }
		  for (String key: pattern.keySet()) {
		  	if (!key.equals(ML.PERFORMATIVE) && !key.equals(ML.ACT))
		      buf.append('-').append(key).append('-').append(pattern.get(key).toString());
		  }
		  name = buf.toString();
		}
		return name;
	}

	/**a class representation of Event Descriptor Lisp Operator
	 * 
	 * @author 
	 *
	 */
  static class EventDescriptorLispOperator  extends CasaLispOperator {

  	/**constructor for the event descriptor
  	 * 
  	 * @param name					
  	 * @param arglist				
  	 * @param agentClass		
  	 * @param synonyms			
  	 */
  	public EventDescriptorLispOperator(String name, String arglist,	Class<? extends TransientAgent> agentClass, String... synonyms) {
			super(name, arglist, agentClass, new Object() { }.getClass().getEnclosingClass(), synonyms);
		}

  	/**the execute command
  	 * @see CasaLispOperator#execute(TransientAgent,ParamsMap,AgentUI,Environment) 
  	 */
		@SuppressWarnings("unchecked")
		@Override
		public Status execute(TransientAgent agent, ParamsMap params, AgentUI ui, Environment env) {
    	String eventType = getMGT();																						//set default eventType
    	if (params.containsKey("EVENT-TYPE")) {																	//if an event type is in the parameter list
    		String temp = (String)params.getJavaObject("EVENT-TYPE");								//get the event-type
    		if (agent.isA(temp, getMGT()))																					//ensure that temp is a sub-type of ML.EVENT
    			eventType = temp;
    		else																																		//otherwise use the default
    			agent.println("error","Lisp operator "+toString(params)+": Can't accept event type '"+temp+"'; must be a subtype of '"+getMGT()+"'; defaulting to "+getMGT());
    	}
    	
    	Vector<Pair<String,Object>> pairs = new Vector<Pair<String,Object>>();	//create a vector of string-object pairs to extract from the rest of the parameters
    	for (String key: params.keySet()) {																			//for all the keys in the parameters
    		if (!(key.equalsIgnoreCase("EVENT-TYPE") || key.startsWith("__"))){			//if the key is not an EVENT-TYPE and it does not start with __
    			Object val = params.getJavaObject(key);																	//get the object that this key represents
    			if (val!=null && (val instanceof String ? ((String)val).length()>0 : true)) { //if the object is not null
    			  pairs.add(new Pair<String, Object>(key,val));														//add the key-object pair to the vector
    			}
    		}
    	}
    	Pair<?,?> []array = new Pair<?,?>[pairs.size()];												//create an array of Pairs with Comparable parameters
    	
    	int i = 0;																															//initialize indexer
    	for (Pair<String,Object> p: pairs) {																		//for each pair in the vector of pairs
    		array[i++] = p;																													//put it in the array at i then increment i (this line crashes if array is not generic)
    	}
    	return new StatusObject<EventDescriptor>(
    	             0, 
                   makeNew(agent, eventType, (Pair<String,Object> [])array));	//return a new statusObject with object type EventDescriptor with 0 for success (cast generics here) 
    }

  	/**a function that returns an ML.EVENT (the most general type)
  	 * 
  	 * @return The most general type name this class will accept
  	 */
		protected String getMGT() {return ML.EVENT;}
		
		/**a function that makes returns new EventDescriptor out of the parameters
		 * 
		 * @param agent		a PolicyAgentInterface (can be 0)
		 * @param type		the type of the event being described
		 * @param pairs		the key-object pairs associated with the event 
		 * @return
		 */
		protected EventDescriptor makeNew(PolicyAgentInterface agent, String type, Pair<String,Object>[] pairs) {
	  	return new EventDescriptor(agent, type, pairs);
	  }

		protected String getLispFunctionName() {return "EVENT-DESCRIPTOR";}

  } //end class EventDescriptorLispOperator
  
  /**
   * Lisp operator: (EVENT-DESCRIPTOR performative act)<br>
   * Create a EventDescriptor object.
   */
  @SuppressWarnings("unused")
	private static final CasaLispOperator EVENT_DESCRIPTOR =
    new EventDescriptorLispOperator("EVENT-DESCRIPTOR", "\"!Return a new EventDescriptor that matches fields according the the keys and values.\" "+
    						"EVENT-TYPE \"@java.lang.String\" \"!The most specific event to match\" "+
    						"&ALLOW-OTHER-KEYS", TransientAgent.class);
}
